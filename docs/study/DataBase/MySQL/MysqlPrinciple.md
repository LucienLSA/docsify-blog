---
title: MYSQL底层原理学习
katex: true
categories: 
- mysql
tags:
- 笔记
- mysql
---

## InnoDB数据页结构
### 行格式
一行数据拿出来，先放到内存中，再用cpu筛选，与输入的sql程序进行比较

#### InnoDB行格式
一行记录可以不同格式存在InnoDB中，行格式分别为Compact、Redundant、Dynamic和Compressed

##### COMPACT行格式
变长字段长度列表 + NULL标志位 + 记录头信息 + 列1数据 + 列2数据

1. 变长字段长度列表
CHAR是固定长度类型，VARCHAR(M),M表示最大能存的字符 

##### 行溢出
某一行长度受限制65535个字节，需要加入变长字段和NULL标志位(3个字节)

在记录真实数据处存储一部分数据。
但一页所占用的空间16kb，即分页存储，在前一页地方存下一页的地址

##### Dynamic行格式
与COMPACT行格式不同在于处理行溢出数据，Dynamic把所有的数据存储在其他页面中

##### Compressed行格式
对Dynamic存储方式进行 压缩

##### 索引
InnoDB引擎中，数据插入到表，直接进行排序。优点
1. 排好序查询更快
2. Page Directory，建立目录对数据进行分组。先比较页目录，再比较目录中某一组的数据，进而确定搜索范围。 也可用二分法快速查询

若插入的数据量特别大，页目录很多的情况下，加入一个目录页，对页目录进行分组（记录最小的值和页号--[主键和指针]）指针指向数据

B+树，数据存储在B+树的叶子节点中，一个节点可存放多个数据，存放的数据多，树的度低，且查询数据时根据叶子节点指向更快

如果没有主键或者唯一索引，默认生成一个字段row_id(作为行ID，唯一标识一条记录)

主键或者自增ID需要小，否则存储的行树会少，页数变多，树的高度变高，则查询数据时会变慢。

页数变多时，起始页可能发生改变。



#### 局部性原理
一行代码有可能取一个字节的数据，可能立马会用到相邻的数据。利用局部性原理，在取一个数据的时候，会多取一些数据从磁盘放到内存中。这时再用数据就更快了

取一页数据为16kb，单位

### 数据页结构
页结构主要为User Records/ Free Space/ Page Directory

#### User Records
实际存储的行记录内容

#### Free Space
空闲空间

#### Page Directory
页中某些记录的相对位置

## B+树索引

#### 聚集索引
创建表时，创建新的一页，这一页放不下后，再创建一页。先将第一页复制一份，再将创建第二页，而原来的第一页就改成目录页，则目录页作为起始页是不变的

#### 辅助索引
对数据某些字段进行索引，存在叶子节点中（主键+数据），上面的非叶子节点只取每一页的最小索引值



#### 查询
1. 辅助索引+回表
找两次，一是根据辅助索引找主键，第二是根据主键在主键索引中再找一次

2. 全表扫描

查询优化器：辅助索引找出的个数占整个表的主键值的个数很大，则认为是全表扫描

基于sql语句的条件，根据索引，缩小查询范围

mql中的utf8一般指的是utf8mb4

#### 匹配列前缀
```sql
select * from t1 where b like '%101%'
```
用不到索引，因为101字符串没有排序，只能全盘扫描

假设对url列创建索引，查询以com为后缀的网址，将后缀查询改写成前缀查询，把表中的数据全部逆序存储

```
moc.udiab.wwww
moc.qq.www
```

##### 以bcd作为索引值进行查询
```sql
explain select * from t1 where b = 1 and c = 1 and d = 1;
```

b=1;能进行查询(1**)，但是c=1则不能比较(*1*)

##### 以b>1 and b<8
找两个端点值b=1和b=8，之间范围的数据

##### 以b>1 and c=1
b>1索引后，对c=1字段并不能用，因为仍没有排好序

##### order by 排序进行索引
按照b值、c值、d值相同的记录，分别进行分组
```sql
explain select b from t1 order by b, c, d;
```
b列值相同的记录，按照c、d排序
```sql
explain select b from t1 where b=1 order by c, d;
```
##### group by 索引

##### 使用主键索引
查询优化器中，对b、c、d进行索引时，也可加上主键索引
```sql
explain select * from t1 where b = 1 and c = 1 and d = 1 and a > 1;
```



#### NULL值
NULL值可忽略，或表示最小值


## 事务和锁原理

### 事务是什么
场景：小明向小强转账10元（一方转出，另一方转入）
#### 原子性
转账要么转入成功，要么失败，不存在中间状态

#### 隔离性
1. 小明向小强转账10元
2. 小明向小红转账10元

以上两个操作互不能影响

#### 一致性
每一次转账完成，保证整个余额等于所有账户的收入减去所有账户的支出。如果小明向小强转账10元，但只转了一半，小明少了10元，而小强没有增加10元，则不满足一致性

#### 持久性
转账交易记录需要永久保存

#### 自动提交
一段sql语句中，先开启一个事务，再执行sql，提交这个事务。

##### 关闭自动提交
1. 显式使用START TRANSACTION或BEGIN开启一个事务
2. 系统变量autocommit的值设置为OFF，写入多条语句后，显式写出COMMIT语句将事务提交，或显式写出ROLLBACK语句将事务回滚


ROLLBACK回滚，手动回滚事务时使用

#### 隐式提交
当关闭自动提交后，输入某些语句悄悄提交
1. 修改数据库对象，数据库、表、视图等
2. 隐式使用数据库或修改mysql数据库的表
3. 事务还未提交或回滚就又使用START TRANSACTION或BEGIN开启一个事务，隐式地提交上一个事务
4. 加载数据，导入数据

#### 保存点
事务对应地数据库语句打点，调用回滚ROLLBACK语句会指定回滚到某个点，而不是回到最初地原点
```sql
SAVEPOINT 保存点名称;
```

回滚到某个保存点
```sql
ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;
```

### 事务隔离级别是什么？有哪些隔离级别？每个隔离级别分别会出现什么现象？
修改隔离级别和查看隔离级别
```sql
set session transaction isolation level read uncommitted;
select @@tx_islation;
```
#### 读未提交(READ UNCOMMITTED)
一个事务可读到其他事务还没有提交的数据，会出现脏读

#### 读已提交(READ COMMITED)
一个事务只能读到另一个已经提交的事务修改的数据，并其他事务每对该数据进行一次修改并提交后，该事务都能查询到最新值，出现不可重复读、幻读（不可重复读出现在一行，幻读出现在多行）


数据的隐藏列transaction_id是事务ID，最近一次修改事务的ID

一行数据的更新，某事务需要自己更新，存入到“版本链”。A事务读取一个版本的数据值，当其他事务对其版本链修改，其他事务只能读到修改的数据值。A事务不会读到其他事务的改动。


READVIEWS： A事务select数据，生成readview，m_ids保存了A事务读的时候，有哪些事务是活跃的（未提交的）。

查找m_ids已经提交的事务，判断版本链中哪个版本是当前事务可见的

当B事务提交时，在readviews中，m_ids没有B提交的事务ID，可取出修改提交的数据值


#### 可重复读(REPEATABLE READ)
一个事务第一次读过某条记录后，其他事务修改了该记录的值并且提交，该事务之后再读这条记录，读到仍是第一次读到的值，而不是每一次都读到不同的数据，但还是会出现幻读

commit之后进行select 用之前生成的readview


#### 串行化(SERIALIZABLE)
对以上3种隔离级别都允许对同一条记录同时进行读读，读写，写读并发操作，如果不允许读写、写读的并发操作，使用串行化隔离级别，对同一条记录的操作是串行的，不会出现脏读和幻读等现象


### MVCC
多版本并发控制，指在读已提交和可重复读两种隔离级别的事务上执行普通的SELECT操作访问记录的版本链的过程，可使不同事务的读写、写读并发执行，提升系统性能。

读已提交和可重复读很大的区别是，生成Readview的时机不同，读已提交在每一次进行普通SELECT操作都会生成一个Readview，而可重复读只在第一次进行普通SELECT操作前生成一个Readview，之后的查询都使用这个Readview



### 锁是什么？mysql中有哪些锁
事务结束，即提交或者回滚，将锁释放掉

锁在事务中使用，如果开启了autocommit，写select SQL语句，会默认开启一个事务，再执行这个SQL，再提交该事务

#### 读锁与写锁
读锁：一行数据，其他人不能对其更新数据，只能读

写锁：一行数据，其他人不能对其更新，也不能读


一个资源上可加多个读锁，不能加多个写锁

##### 读操作
使用 select * from t1 where a = 1， 对于普通SELECT语句，InnoDB不会加任何锁

1. select lack in share mode
加上S锁（读锁），允许其他事务继续获取S锁，不能获取记录的X锁（会阻塞）

2. select for update
加上X锁（写锁），不允许其他事务获取S锁和X锁

##### 写操作
1. DELECT
删除一条数据，先对其加X锁，再执行删除操作

2. INSERT
插入一条数据，先加“隐式锁”，保护这条新插入的记录，在本事务提交前不被别的事务访问到

3. UPDATE
被更新的列，修改前后没有导致存储空间变化，先给记录加X锁，再对记录进行修改

被更新的列，修改前后导致存储空间变化，先给记录加X锁，将记录删掉，再insert一条新纪录

#### 行锁
LOCK_REC_NOT_GAP: 单个行记录的锁

LOCK_GAP: 间隙锁，锁定一个范围，不包括记录本身。GAP锁目的是为防止同一事务的两次当前读，出现幻读情况

LOCK_ORDINARY: 间隙锁，锁定一个范围，并锁定记录本身，对行查询，都采用该方法


##### 读已提交级别下锁
手动开启事务，

1. 查询使用主键
只需要在主键值对应的那一条数据加锁

2. 查询使用唯一索引
只会对查询值所对应的唯一索引记录项和对应的聚集索引上的项加锁即可

3. 查询普通索引
对满足条件的索引记录都加上锁，勇士对这些索引记录对应的聚集索引上的项也加上锁

4. 查询没有使用索引
与上同理，即只把查询出来的行进行加锁


对已经查出来的数据加锁后，但仍可以插入

##### 可重复读隔离级别下的锁
对已经查出来的数据加锁后，插不进去

1. 查询普通索引
在间隙中加锁，会防止幻读现象，远一点的数据进行插入即可

对于select * from t1 where a > 1， 查询出来的数据较多，则对于该数据范围内无法进行插入

2. 全表扫描
将整个表所有的行和间隙都锁住，可解决幻读现象


#### 表级别的读锁和写锁
##### IS锁和IX锁
行写锁存在时，不需要加表写锁，但一行一行查找效率低

表上加入意向锁，当事务准备在某条记录上加锁时，需要在先在表级别上加一个意向锁，与行锁不冲突

IS锁和IX锁是表级锁，为在之后加表级别的S锁和X锁可快速判断记录是否被上锁














